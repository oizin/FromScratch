{"title":"Missing data and directed acyclic graphs","markdown":{"yaml":{"title":"Missing data and directed acyclic graphs","subtitle":"Notes on Mohan & Pearl (2021)","date":"February 2025","bibliography":"references.bib","format":{"html":{"code-fold":"show"}},"execute":{"freeze":"auto","cache":true}},"headingText":"Missingness graphs","containsRefs":false,"markdown":"\n\n```{r setup}\n#| echo: false\n#| warning: false\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(dagitty)\nlibrary(ggdag)\n```\n\n\nIn many data science applications it is quite common for there to be a need to account for missing data. Missingness graphs (or m-graphs) extend traditional causal graphs by making explicit the presence of missing variables [@mohan2021graphical]. Let $G(\\textbf{V}, E)$ be a causal directed acyclic graph (DAG) where $\\textbf{V}$ is the set of nodes (variables) and $E$ is the set of edges (causal relationships). The nodes are partitioned into five categories:\n\n$$\\textbf{V} = V_o \\cup V_m \\cup U \\cup V^* \\cup R$$\n\nwhere $V_o$ is the set of fully observed variables, and $V_m$ is the set of partially observed variables. Associated with every partially observed variable are the proxy variables that is actually observed $V^*_i$ and $R_{v_i}$ a binary variable which represents the status of the causal mechanism responsible for the missingness of $V^*_i$. These are related as:\n\n$$v_i^* = f(r_{v_i},v_i) = \\begin{cases}\n  v_i, &  \\text{if $r_{v_i} = 0$} \\\\\n  m, &  \\text{if $r_{v_i} = 1$} \n\\end{cases}$$\n\nThis simply links that the missingness indicator $r\\_{v_i}$ is one we don't observe the variable (duh), a key question will be whether we can reasonably determine why $r_{v_i}=1$ using the observed data. $V^∗$ is the set of all proxy variables and $R$ is the set of all causal mechanisms that are responsible for missingness. $U$ is the set of unobserved nodes, also called latent variables. These sets of variables can be grouped into two to define the missing data distribution, $P(V^∗,V_o, R)$ and the underlying distribution $P(V_o,V_m, R)$.\n\n## Recoverability\n\nWhen we have missing data we need a way to determine whether our desired parameter (statistical model, causal effect etc) is recoverable. Recoverability is defined as whether any method exists that produces a consistent estimate of a desired parameter and, if so, how.\n\n## Examples\n\nOur target quantity is a prediction of the number of usable cleavage stage (day 3) embryos $C$ a woman is likely to get from IVF given her age $A$ and the number of fertilised oocytes (zygotes / day 1 embryos) $Z$. However, our data source only records whether our embryos reached cleavage stage if they are transferred to the woman prior to blastocyst stage (day 5), with $B$ the number of blastocysts. So we only observed $B$ or $C$. We'll consider a few m-DAGs for this problem, with $U$ an unmeasured variable representing prognosis (aka degree of infertility or oocyte/embryo quality).\n\n### 1. Recoverable (missing at random)\n\nIn this first m-DAG, the decision (missingness mechanism $R_c$) around whether to transfer at cleavage or blastocyst stage is taken based on the number of fertilised oocytes $Z$.\n\n```{r}\n#| code-fold: true\ndag <- dagitty('dag {\n    bb=\"0,0,1,1\"\n    \"B*\" [pos=\"0.381,0.493\"]\n    \"C*\" [pos=\"0.378,0.416\"]\n    A [pos=\"0.255,0.232\"]\n    B [pos=\"0.315,0.450\"]\n    C [pos=\"0.311,0.376\"]\n    Rb [pos=\"0.434,0.377\"]\n    Rc [pos=\"0.376,0.338\"]\n    U [pos=\"0.346,0.231\"]\n    Z [pos=\"0.310,0.299\"]\n    A -> Z\n    B -> \"B*\"\n    C -> B\n    C -> \"C*\"\n    Rb -> \"B*\"\n    Rc -> \"C*\"\n    Rc -> Rb\n    U -> Z\n    U -> C\n    U -> B\n    Z -> C\n    Z -> Rc\n}')\nggdag(dag) + \n    scale_y_reverse() + \n    theme_void(base_size = 22)\n```\n\n```{r}\n#| code-fold: true\nf_n_zy <- function(age, prog) {\n    stopifnot(length(age) == length(prog))\n    n <- length(age)\n    n_zy <- (age == \"<35\" & prog == \"good\") * rpois(n,6) +\n    (age == \"<35\" & prog == \"bad\") * rpois(n,4) +\n    (age == \"≥35\" & prog == \"good\") * rpois(n,5) +\n    (age == \"≥35\" & prog == \"bad\") * rpois(n,3) + 1\n    n_zy\n}\nf_n_cl <- function(n_zy, prog) {\n    stopifnot(length(n_zy) == length(prog))\n    n <- length(n_zy)\n    n_cl <- (prog == \"good\") * rbinom(n, size = n_zy, prob = 0.7) +\n    (prog == \"bad\") * rbinom(n, size = n_zy, prob = 0.7)\n    n_cl\n}\nf_n_bl <- function(n_cl, prog) {\n    stopifnot(length(n_cl) == length(prog))\n    n <- length(n_cl)\n    n_bl <- (prog == \"good\") * rbinom(n, size = n_cl, prob = 0.7) +\n    (prog == \"bad\") * rbinom(n, size = n_cl, prob = 0.7)\n    n_bl\n}\ngen_data <- function(n,f_p_bl) {\n    age <- sample(c(\"<35\",\"≥35\"),n,prob = c(0.4,0.6),replace = TRUE)\n    prog <- sample(c(\"good\",\"bad\"),n,prob = c(0.3,0.7),replace = TRUE)\n    n_zy <- f_n_zy(age,prog)\n    n_cl <- f_n_cl(n_zy, prog)\n    n_bl <- f_n_bl(n_cl, prog)\n    p_bl <- f_p_bl(age, n_zy, n_cl)\n    bl <- runif(n) < p_bl\n    data.table(age,prog,n_zy,n_cl,n_bl,p_bl,bl)\n}\nmake_observed <- function(df) {\n    df1 <- copy(df)\n    df1[bl == TRUE,n_cl := NA]\n    df1[bl == FALSE,n_bl := NA]\n    df1[,p_bl := NULL]\n    df1[,prog := NULL]\n    df1\n}\n```\n\nBased on this, conditioning on $Z$ d-separates $R_c$ and $C$, $C \\perp R_c | Z$, so we can use the available data:\n\n$$\n\\begin{split}\nP(C|A=a,Z=z) &= P(C|A=a,Z=z,R_c=0) \\\\\n    &= P(C^*|A=a,Z=z,R_c=0) \n\\end{split}\n$$\n\nIf we only wanted to predict based on female age, we can also do so by summing over the distribution of $Z$:\n\n$$\n\\begin{split}\nP(C|A=a) &= \\sum_z P(C|A=a,Z=z) P(Z=z|A=a) \\\\\n    &= \\sum_z P(C|A=a,Z=z,R_c=0) P(Z=z|A=a) \\\\\n    &= \\sum_z P(C^*|A=a,Z=z,R_c=0) P(Z=z|A=a) \\\\\n\\end{split}\n$$\n\nAs shown below, there is no difference between models fit on the observed data (with missingness) and models fit on a theoretically complete (no missingness) dataset.\n\n```{r}\n#| code-fold: true\nf_p_bl <- function(age, n_zy, n_cl) {\n    p_bl <- fifelse(n_zy >= 4, 0.8, 0.2)\n    p_bl\n}\ndf <- gen_data(1000,f_p_bl)\ndf1 <- make_observed(df)\nmiss_cl <- lm(n_cl ~ n_zy + age, data = df1)\ntrue_cl <- lm(n_cl ~ n_zy + age, data = df)\n\n\nmiss_pred = predict(miss_cl,newdata=df1)\ntrue_pred = predict(true_cl,newdata=df1)\n\nres_df = data.table(miss_pred, true_pred)\n\nggplot(res_df,aes(x = miss_pred,y=true_pred)) + \n    geom_point() +\n    labs(x= \"Predictions made with observed data\",\n         y = \"Predictions made with with complete (unobserved) data\",\n    title = \"Comparison of predictions made with observed and complete data\") +\n    geom_abline(intercept=0,slope=1,linetype=2)+\n  theme_bw(base_size=14)\n```\n\n### 2. Recoverable (missing at random)\n\nThis second example expands the factors that determine the number of cleavage and blastocyst stage embryos to include female age, and the unmeasured prognosis variable. Further, female age is also used to determine whether to transfer cleavage or blastocyst stage embryos. Despite the increased complexity, things are pretty much the same, to d-separate $C$ and $R_c$ we need to condition on $A$ and $Z$ making $P(C|A,Z)$ recoverable.\n\n```{r}\n#| code-fold: true\ndag <- dagitty('dag {\n    bb=\"0,0,1,1\"\n    \"B*\" [pos=\"0.381,0.493\"]\n    \"C*\" [pos=\"0.378,0.416\"]\n    A [pos=\"0.255,0.232\"]\n    B [pos=\"0.315,0.450\"]\n    C [pos=\"0.311,0.376\"]\n    Rb [pos=\"0.434,0.377\"]\n    Rc [pos=\"0.376,0.338\"]\n    U [pos=\"0.346,0.231\"]\n    Z [pos=\"0.310,0.299\"]\n    A -> Z\n    B -> \"B*\"\n    C -> B\n    C -> \"C*\"\n    Rb -> \"B*\"\n    Rc -> \"C*\"\n    Rc -> Rb\n    U -> Z\n    Z -> C\n    Z -> Rc\n    A -> C\n    A -> B\n    A -> Rc\n    U -> C\n    U -> B\n}')\nggdag(dag) + \n    scale_y_reverse() + \n    theme_void(base_size = 22)\n```\n\n### 3. Missing not at random (non-recoverable)\n\nIn this final example we consider a case where $P(C|A,Z)$ is non-recoverable. The mechanism for this is vary simple, $C$ causes its own missingness. In this IVF example this could occur if the decision to transfer at cleavage or blastocyst stage is taken based on the number of embryos that reach cleavage stage, e.g. too few have survived to cleavage then transfer (or freeze) now vs. good survival rate then continue culture to blastocyst. In the m-graph below there is no way to block the path between $C$ and $R_c$. This is an example of a \"missing not at random\" (MNAR) problem.\n\n```{r}\n#| code-fold: true\ndag <- dagitty('dag {\n    bb=\"0,0,1,1\"\n    \"B*\" [pos=\"0.381,0.493\"]\n    \"C*\" [pos=\"0.378,0.416\"]\n    A [pos=\"0.255,0.232\"]\n    B [pos=\"0.315,0.450\"]\n    C [pos=\"0.311,0.376\"]\n    Rb [pos=\"0.434,0.377\"]\n    Rc [pos=\"0.376,0.338\"]\n    U [pos=\"0.346,0.231\"]\n    Z [pos=\"0.310,0.299\"]\n    A -> Z\n    B -> \"B*\"\n    C -> B\n    C -> \"C*\"\n    Rb -> \"B*\"\n    Rc -> \"C*\"\n    Rc -> Rb\n    U -> Z\n    Z -> C\n    Z -> Rc\n    C -> Rc\n}')\nggdag(dag) + \n    scale_y_reverse() + \n    theme_void(base_size = 22)\n```\n\nNow there is a difference between models fit on the observed data (with missingness) and models fit on a theoretically complete (no missingness) dataset. The linear model built using the observed data has biased parameters (intercept too high, slope too low).\n\n```{r}\n#| code-fold: true\nf_p_bl <- function(age, n_zy, n_cl) {\n    p_bl <- fifelse(n_cl >= 2, 0.8, 0.2)\n    p_bl\n}\ndf <- gen_data(1000,f_p_bl)\ndf1 <- make_observed(df)\nmiss_cl <- lm(n_cl ~ n_zy + age, data = df1)\ntrue_cl <- lm(n_cl ~ n_zy + age, data = df)\n\n\nmiss_pred = predict(miss_cl,newdata=df1)\ntrue_pred = predict(true_cl,newdata=df1)\n\nres_df = data.table(miss_pred, true_pred)\n\nggplot(res_df,aes(x = miss_pred,y=true_pred)) + \n    geom_point() +\n    stat_smooth() +\n      labs(x= \"Predictions made with observed data\",\n         y = \"Predictions made with with complete (unobserved) data\",\n    title = \"Comparison of predictions made with observed and complete data\") +\n    geom_abline(intercept=0,slope=1,linetype=2) +\n  theme_bw(base_size=14)\n```\n","srcMarkdownNoYaml":"\n\n```{r setup}\n#| echo: false\n#| warning: false\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(dagitty)\nlibrary(ggdag)\n```\n\n## Missingness graphs\n\nIn many data science applications it is quite common for there to be a need to account for missing data. Missingness graphs (or m-graphs) extend traditional causal graphs by making explicit the presence of missing variables [@mohan2021graphical]. Let $G(\\textbf{V}, E)$ be a causal directed acyclic graph (DAG) where $\\textbf{V}$ is the set of nodes (variables) and $E$ is the set of edges (causal relationships). The nodes are partitioned into five categories:\n\n$$\\textbf{V} = V_o \\cup V_m \\cup U \\cup V^* \\cup R$$\n\nwhere $V_o$ is the set of fully observed variables, and $V_m$ is the set of partially observed variables. Associated with every partially observed variable are the proxy variables that is actually observed $V^*_i$ and $R_{v_i}$ a binary variable which represents the status of the causal mechanism responsible for the missingness of $V^*_i$. These are related as:\n\n$$v_i^* = f(r_{v_i},v_i) = \\begin{cases}\n  v_i, &  \\text{if $r_{v_i} = 0$} \\\\\n  m, &  \\text{if $r_{v_i} = 1$} \n\\end{cases}$$\n\nThis simply links that the missingness indicator $r\\_{v_i}$ is one we don't observe the variable (duh), a key question will be whether we can reasonably determine why $r_{v_i}=1$ using the observed data. $V^∗$ is the set of all proxy variables and $R$ is the set of all causal mechanisms that are responsible for missingness. $U$ is the set of unobserved nodes, also called latent variables. These sets of variables can be grouped into two to define the missing data distribution, $P(V^∗,V_o, R)$ and the underlying distribution $P(V_o,V_m, R)$.\n\n## Recoverability\n\nWhen we have missing data we need a way to determine whether our desired parameter (statistical model, causal effect etc) is recoverable. Recoverability is defined as whether any method exists that produces a consistent estimate of a desired parameter and, if so, how.\n\n## Examples\n\nOur target quantity is a prediction of the number of usable cleavage stage (day 3) embryos $C$ a woman is likely to get from IVF given her age $A$ and the number of fertilised oocytes (zygotes / day 1 embryos) $Z$. However, our data source only records whether our embryos reached cleavage stage if they are transferred to the woman prior to blastocyst stage (day 5), with $B$ the number of blastocysts. So we only observed $B$ or $C$. We'll consider a few m-DAGs for this problem, with $U$ an unmeasured variable representing prognosis (aka degree of infertility or oocyte/embryo quality).\n\n### 1. Recoverable (missing at random)\n\nIn this first m-DAG, the decision (missingness mechanism $R_c$) around whether to transfer at cleavage or blastocyst stage is taken based on the number of fertilised oocytes $Z$.\n\n```{r}\n#| code-fold: true\ndag <- dagitty('dag {\n    bb=\"0,0,1,1\"\n    \"B*\" [pos=\"0.381,0.493\"]\n    \"C*\" [pos=\"0.378,0.416\"]\n    A [pos=\"0.255,0.232\"]\n    B [pos=\"0.315,0.450\"]\n    C [pos=\"0.311,0.376\"]\n    Rb [pos=\"0.434,0.377\"]\n    Rc [pos=\"0.376,0.338\"]\n    U [pos=\"0.346,0.231\"]\n    Z [pos=\"0.310,0.299\"]\n    A -> Z\n    B -> \"B*\"\n    C -> B\n    C -> \"C*\"\n    Rb -> \"B*\"\n    Rc -> \"C*\"\n    Rc -> Rb\n    U -> Z\n    U -> C\n    U -> B\n    Z -> C\n    Z -> Rc\n}')\nggdag(dag) + \n    scale_y_reverse() + \n    theme_void(base_size = 22)\n```\n\n```{r}\n#| code-fold: true\nf_n_zy <- function(age, prog) {\n    stopifnot(length(age) == length(prog))\n    n <- length(age)\n    n_zy <- (age == \"<35\" & prog == \"good\") * rpois(n,6) +\n    (age == \"<35\" & prog == \"bad\") * rpois(n,4) +\n    (age == \"≥35\" & prog == \"good\") * rpois(n,5) +\n    (age == \"≥35\" & prog == \"bad\") * rpois(n,3) + 1\n    n_zy\n}\nf_n_cl <- function(n_zy, prog) {\n    stopifnot(length(n_zy) == length(prog))\n    n <- length(n_zy)\n    n_cl <- (prog == \"good\") * rbinom(n, size = n_zy, prob = 0.7) +\n    (prog == \"bad\") * rbinom(n, size = n_zy, prob = 0.7)\n    n_cl\n}\nf_n_bl <- function(n_cl, prog) {\n    stopifnot(length(n_cl) == length(prog))\n    n <- length(n_cl)\n    n_bl <- (prog == \"good\") * rbinom(n, size = n_cl, prob = 0.7) +\n    (prog == \"bad\") * rbinom(n, size = n_cl, prob = 0.7)\n    n_bl\n}\ngen_data <- function(n,f_p_bl) {\n    age <- sample(c(\"<35\",\"≥35\"),n,prob = c(0.4,0.6),replace = TRUE)\n    prog <- sample(c(\"good\",\"bad\"),n,prob = c(0.3,0.7),replace = TRUE)\n    n_zy <- f_n_zy(age,prog)\n    n_cl <- f_n_cl(n_zy, prog)\n    n_bl <- f_n_bl(n_cl, prog)\n    p_bl <- f_p_bl(age, n_zy, n_cl)\n    bl <- runif(n) < p_bl\n    data.table(age,prog,n_zy,n_cl,n_bl,p_bl,bl)\n}\nmake_observed <- function(df) {\n    df1 <- copy(df)\n    df1[bl == TRUE,n_cl := NA]\n    df1[bl == FALSE,n_bl := NA]\n    df1[,p_bl := NULL]\n    df1[,prog := NULL]\n    df1\n}\n```\n\nBased on this, conditioning on $Z$ d-separates $R_c$ and $C$, $C \\perp R_c | Z$, so we can use the available data:\n\n$$\n\\begin{split}\nP(C|A=a,Z=z) &= P(C|A=a,Z=z,R_c=0) \\\\\n    &= P(C^*|A=a,Z=z,R_c=0) \n\\end{split}\n$$\n\nIf we only wanted to predict based on female age, we can also do so by summing over the distribution of $Z$:\n\n$$\n\\begin{split}\nP(C|A=a) &= \\sum_z P(C|A=a,Z=z) P(Z=z|A=a) \\\\\n    &= \\sum_z P(C|A=a,Z=z,R_c=0) P(Z=z|A=a) \\\\\n    &= \\sum_z P(C^*|A=a,Z=z,R_c=0) P(Z=z|A=a) \\\\\n\\end{split}\n$$\n\nAs shown below, there is no difference between models fit on the observed data (with missingness) and models fit on a theoretically complete (no missingness) dataset.\n\n```{r}\n#| code-fold: true\nf_p_bl <- function(age, n_zy, n_cl) {\n    p_bl <- fifelse(n_zy >= 4, 0.8, 0.2)\n    p_bl\n}\ndf <- gen_data(1000,f_p_bl)\ndf1 <- make_observed(df)\nmiss_cl <- lm(n_cl ~ n_zy + age, data = df1)\ntrue_cl <- lm(n_cl ~ n_zy + age, data = df)\n\n\nmiss_pred = predict(miss_cl,newdata=df1)\ntrue_pred = predict(true_cl,newdata=df1)\n\nres_df = data.table(miss_pred, true_pred)\n\nggplot(res_df,aes(x = miss_pred,y=true_pred)) + \n    geom_point() +\n    labs(x= \"Predictions made with observed data\",\n         y = \"Predictions made with with complete (unobserved) data\",\n    title = \"Comparison of predictions made with observed and complete data\") +\n    geom_abline(intercept=0,slope=1,linetype=2)+\n  theme_bw(base_size=14)\n```\n\n### 2. Recoverable (missing at random)\n\nThis second example expands the factors that determine the number of cleavage and blastocyst stage embryos to include female age, and the unmeasured prognosis variable. Further, female age is also used to determine whether to transfer cleavage or blastocyst stage embryos. Despite the increased complexity, things are pretty much the same, to d-separate $C$ and $R_c$ we need to condition on $A$ and $Z$ making $P(C|A,Z)$ recoverable.\n\n```{r}\n#| code-fold: true\ndag <- dagitty('dag {\n    bb=\"0,0,1,1\"\n    \"B*\" [pos=\"0.381,0.493\"]\n    \"C*\" [pos=\"0.378,0.416\"]\n    A [pos=\"0.255,0.232\"]\n    B [pos=\"0.315,0.450\"]\n    C [pos=\"0.311,0.376\"]\n    Rb [pos=\"0.434,0.377\"]\n    Rc [pos=\"0.376,0.338\"]\n    U [pos=\"0.346,0.231\"]\n    Z [pos=\"0.310,0.299\"]\n    A -> Z\n    B -> \"B*\"\n    C -> B\n    C -> \"C*\"\n    Rb -> \"B*\"\n    Rc -> \"C*\"\n    Rc -> Rb\n    U -> Z\n    Z -> C\n    Z -> Rc\n    A -> C\n    A -> B\n    A -> Rc\n    U -> C\n    U -> B\n}')\nggdag(dag) + \n    scale_y_reverse() + \n    theme_void(base_size = 22)\n```\n\n### 3. Missing not at random (non-recoverable)\n\nIn this final example we consider a case where $P(C|A,Z)$ is non-recoverable. The mechanism for this is vary simple, $C$ causes its own missingness. In this IVF example this could occur if the decision to transfer at cleavage or blastocyst stage is taken based on the number of embryos that reach cleavage stage, e.g. too few have survived to cleavage then transfer (or freeze) now vs. good survival rate then continue culture to blastocyst. In the m-graph below there is no way to block the path between $C$ and $R_c$. This is an example of a \"missing not at random\" (MNAR) problem.\n\n```{r}\n#| code-fold: true\ndag <- dagitty('dag {\n    bb=\"0,0,1,1\"\n    \"B*\" [pos=\"0.381,0.493\"]\n    \"C*\" [pos=\"0.378,0.416\"]\n    A [pos=\"0.255,0.232\"]\n    B [pos=\"0.315,0.450\"]\n    C [pos=\"0.311,0.376\"]\n    Rb [pos=\"0.434,0.377\"]\n    Rc [pos=\"0.376,0.338\"]\n    U [pos=\"0.346,0.231\"]\n    Z [pos=\"0.310,0.299\"]\n    A -> Z\n    B -> \"B*\"\n    C -> B\n    C -> \"C*\"\n    Rb -> \"B*\"\n    Rc -> \"C*\"\n    Rc -> Rb\n    U -> Z\n    Z -> C\n    Z -> Rc\n    C -> Rc\n}')\nggdag(dag) + \n    scale_y_reverse() + \n    theme_void(base_size = 22)\n```\n\nNow there is a difference between models fit on the observed data (with missingness) and models fit on a theoretically complete (no missingness) dataset. The linear model built using the observed data has biased parameters (intercept too high, slope too low).\n\n```{r}\n#| code-fold: true\nf_p_bl <- function(age, n_zy, n_cl) {\n    p_bl <- fifelse(n_cl >= 2, 0.8, 0.2)\n    p_bl\n}\ndf <- gen_data(1000,f_p_bl)\ndf1 <- make_observed(df)\nmiss_cl <- lm(n_cl ~ n_zy + age, data = df1)\ntrue_cl <- lm(n_cl ~ n_zy + age, data = df)\n\n\nmiss_pred = predict(miss_cl,newdata=df1)\ntrue_pred = predict(true_cl,newdata=df1)\n\nres_df = data.table(miss_pred, true_pred)\n\nggplot(res_df,aes(x = miss_pred,y=true_pred)) + \n    geom_point() +\n    stat_smooth() +\n      labs(x= \"Predictions made with observed data\",\n         y = \"Predictions made with with complete (unobserved) data\",\n    title = \"Comparison of predictions made with observed and complete data\") +\n    geom_abline(intercept=0,slope=1,linetype=2) +\n  theme_bw(base_size=14)\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","editor":"visual","theme":"cosmo","date-format":"MMMM, YYYY","title-block-banner":true,"title":"Missing data and directed acyclic graphs","subtitle":"Notes on Mohan & Pearl (2021)","date":"February 2025","bibliography":["references.bib"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}